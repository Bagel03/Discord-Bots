"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandsHandler = void 0;
const discord_js_1 = require("discord.js");
const logger_1 = require("./logger");
const fs = require("fs/promises");
const url_1 = require("url");
const serialize_javascript_1 = require("serialize-javascript");
//@ts-ignore
const import_js_1 = require("../esm/import.js");
const helpers_1 = require("./helpers");
const defaultOptions = {
    autoCreateHelpCommand: true,
    caseSensitive: false,
    sendInvalidPermissionsMessage: true,
    footer: "This message was automatically sent using discord-folders v1.0.0",
    embedColor: "#00aaff",
    name: "Commands Handler",
    verbose: true
};
class CommandsHandler {
    constructor(root, options) {
        this.root = root;
        /* Autofill all the options that were not picked with the default options */
        this.options = { ...defaultOptions, ...options };
        this.logger = new logger_1.Logger(this.options.name);
        // Disable non-important logging if verbose is off
        if (!this.options.verbose)
            this.logger.log = () => { };
    }
    setRoot(root) {
        this.root = root;
        this.logger.log("Set root command successfully");
    }
    resolveCommandFromStringArray(commands, client, message) {
        return this.internalResolveCommand(this.root, commands, client, message);
    }
    resolveCommandFromMessage(client, message) {
        return this.internalResolveCommand(this.root, message.content.split(" "), client, message);
    }
    internalResolveCommand(currentCommand, commands, client, message) {
        const child = this.getChildFromCommand(currentCommand, commands[0]);
        if (commands[0].toLowerCase() === "help" && !child) {
            this.logger.log(`Sending help message for command ${currentCommand.name}`);
            this.sendHelpCommandMessage(currentCommand, client, message);
            return true;
        }
        if (commands.length === 1) {
            if (!child && !currentCommand.onCalled) {
                this.logger.error(`Couldn't find subcommand "${commands[0]}" or a default callback in command "${currentCommand.name}"`);
                return this.sendUnknownCommandMessage(currentCommand, commands[0], client, message);
            }
            if (!child) {
                this.logger.log(`Using default callback on command ${currentCommand.name}`);
                if (!currentCommand.hasPermissions(message.member)) {
                    this.logger.log(`Member "${message.member.nickname}" does not have the correct permissions to use command 
    "${currentCommand.name}", sending invalid permissions message`);
                    return this.sendInvalidPermissionsMessage(currentCommand, client, message);
                }
                return currentCommand.onCalled(client, message);
            }
            if (!child.onCalled) {
                this.logger.log(`Sending incorrect usage message for command ${child.name}`);
                return this.sendIncorrectUsageMessage(child, client, message);
            }
            this.logger.log(`Using subcommand "${commands[0]}" in command "${currentCommand.name}"`);
            if (!child.hasPermissions(message.member)) {
                this.logger.log(`Member "${message.member.nickname}" does not have the correct permissions to use command 
"${commands[0]}", sending invalid permissions message`);
                return this.sendInvalidPermissionsMessage(child, client, message);
            }
            return child.onCalled(client, message);
        }
        if (!child && currentCommand.onCalled) {
            this.logger.log(`Using default callback from command "${currentCommand.name}"`);
            if (!currentCommand.hasPermissions(message.member)) {
                this.logger.log(`Member "${message.member.nickname}" does not have the correct permissions to use command 
"${currentCommand.name}", sending invalid permissions message`);
                return this.sendInvalidPermissionsMessage(currentCommand, client, message);
            }

            return currentCommand.onCalled(client, message);
        }
        if (child) {
            return this.internalResolveCommand(child, commands.slice(1), client, message);
        }
        this.logger.error(`Couldn't find subcommand "${commands[0]}" or a default callback in command "${currentCommand.name}"`);
        return this.sendUnknownCommandMessage(currentCommand, commands[0], client, message);
    }
    getChildFromCommand(command, child) {
        if (!command.children)
            return undefined;
        if (this.options.caseSensitive) {
            return command.children[child];
        }
        const entries = Object.entries(command.children);
        const len = entries.length;
        for (let i = len - 1; i > -1; i--) {
            const current = entries[i];
            if (current[0].toLowerCase() === child.toLowerCase())
                return current[1];
        }
        return undefined;
    }
    sendUnknownCommandMessage(currentCommand, unknownCommand, client, message) {
        const description = currentCommand === this.root ?
            `Could not find command *${currentCommand.name}*` : `Could not find subcommand *${unknownCommand}* of command *${currentCommand.name}*`;
        message.channel.send(new discord_js_1.MessageEmbed()
            .setTitle("Unknown command!")
            .setDescription(`${description}. Check your spelling or use the "help" subcommand of any command for more info`)
            .setThumbnail(message.author.displayAvatarURL())
            .setFooter(this.options.footer)
            .setColor(this.options.embedColor)).then(msg => setTimeout(() => { msg.delete(); message.delete(); }, 60000));
    }
    sendInvalidPermissionsMessage(command, client, message) {
        message.channel.send(new discord_js_1.MessageEmbed()
            .setTitle("Invalid permissions!")
            .setDescription(`${message.author} does not have permissions to use command *${command.name}*.`)
            .setThumbnail(message.author.displayAvatarURL())
            .addField("Description: ", command.description)
            .setFooter(this.options.footer)
            .setColor(this.options.embedColor)).then(msg => setTimeout(() => { msg.delete(); message.delete(); }, 60000));
    }
    sendHelpCommandMessage(command, client, message) {
        const title = command === this.root ? message.guild.me.displayName : command.name;
        const emebed = new discord_js_1.MessageEmbed()
            .setTitle(`${helpers_1.titleCase(title)}:`)
            .setDescription(command.description)
            .setThumbnail(message.author.displayAvatarURL())
            .setFooter(this.options.footer)
            .setColor(this.options.embedColor);
        if (typeof command.children === "object") {
            Object.keys(command.children).forEach(key => {
                const child = command.children[key];
                emebed.addField(`${helpers_1.titleCase(child.name)}:`, child.description);
            });
        }
        message.channel.send(emebed).then(msg => setTimeout(() => { msg.delete(); message.delete(); }, 60000));
    }
    sendIncorrectUsageMessage(command, client, message) {
        message.channel.send(new discord_js_1.MessageEmbed()
            .setTitle("Incorrect command usage!")
            .setDescription(`Command *${command.name}* does not have any default behavior, this is probably because it requires a subcommand. Use the *help* subcommand for more info`)
            .setThumbnail(message.author.displayAvatarURL())
            .addField("Command description:", command.description)
            .setFooter(this.options.footer)
            .setColor(this.options.embedColor)).then(msg => setTimeout(() => { msg.delete(); message.delete(); }, 60000));
    }
    serialize() {
        return serialize_javascript_1.default(this.root, {});
    }
    static async loadNewHandlerFromFolder(path, options) {
        const root = await this.loadRootFromFolder(path);
        if (!root) {
            this.staticLogger.error(`Could not load a new commands handler from ${path}, make sure the path is correct.`);
            return false;
        }
        root.name = "root";
        this.staticLogger.log(`Created new commands handler from folder ${path}`);
        return new CommandsHandler(root, options);
    }
    static async loadRootFromFolder(path) {
        const url = url_1.pathToFileURL(path);
        // Make sure the directory exists
        try {
            await fs.access(url);
        }
        catch (err) {
            this.staticLogger.error(`Could not find commands directory "${path}", make sure it exists and that spelling is correct`);
            return false;
        }
        //This is the recursive function that will load each folder and it's children
        const loadFolder = async (url) => {
            // Set stuff up
            const path = url_1.fileURLToPath(url);
            const filename = path.split('\\').pop().split('/').pop();
            const command = { name: filename.replace(/\.[^/.]+$/, "") };
            const data = await fs.lstat(url);
            // If it is a folder, we search for children commands, and don't load any modules
            if (data.isDirectory()) {
                // Just set this as an object to use for later
                command.children = {};
                // Get all the children in this directory 
                const children = await fs.readdir(url);
                // Loop through all the children
                for (let i = 0; i < children.length; i++) {
                    // Check to see if it is the default subcommand, which will be used as the onCalled() for this command
                    if (children[i] === "default.js") {
                        // This is the exact same code as if it were a file
                        const module = await import_js_1.importES6andCJS(path + "\\default.js");
                        if (typeof module.onCalled !== "function") {
                            this.staticLogger.error(`Could not find a "onCalled" exported function from default module "${path}"`);
                        }
                        command.onCalled = module.onCalled;
                        command.description = module.description;
                        command.hasPermissions = module.hasPermissions ?? function () { return true; };
                    }
                    // Get the URL of the children
                    const dir = url_1.pathToFileURL(url_1.fileURLToPath(url) + "\\" + children[i]);
                    const subcommand = await loadFolder(dir);
                    if (subcommand)
                        command.children[subcommand.name] = subcommand;
                }
            }
            else {
                // It must be a file, in which case we can try to import it as a module
                // Ignore files that are not .js files
                if (!path.endsWith(".js")) {
                    this.staticLogger.error(`Found a file that does not end in .js, will be ignoring "${path}"`);
                    return false;
                }
                // Import the file
                const module = await import_js_1.importES6andCJS(path);
                // Make sure we can find the onCalled export
                if (typeof module.onCalled !== "function") {
                    this.staticLogger.error(`Could not find a "onCalled" exported function from module "${path}"`);
                    return false;
                }
                // Set the properties of the command to the modules exports
                command.onCalled = module.onCalled;
                command.description = module.description;
                command.hasPermissions = module.hasPermissions ?? function () { return true; };
                this.staticLogger.log(`Added command from "${path}"`);
            }
            // Fix the description
            command.description = command.description ?? "No description";
            return command;
        };
        const command = await loadFolder(url);
        this.staticLogger.logSuccess(`Finished loading all commands from "${path}"`);
        return command;
    }
    static deserialize(input) {
        return new CommandsHandler(eval(`(${input})`));
    }
}
exports.CommandsHandler = CommandsHandler;
///#region Static
CommandsHandler.staticLogger = new logger_1.Logger("Commands Handler");
